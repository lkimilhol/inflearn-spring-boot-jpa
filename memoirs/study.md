01. implementation 'org.springframework.boot:spring-boot-devtools' 의존성을 추가하고 html 페이지 편집 후 build에서 recompile을 해주면 서버를 다시 띄우지 않아도 html 페이지에 반영이 된다.
02. h2 데이터베이스는 처음에는 파일 모드로 파일을 생성을 하지만 그 이후로는 tcp를 붙여서 네트워크 모드로 접속하게 한다.
03. @Repository는 component scan 대상이다.
04. spring-boot-stater-data-jpa를 통해서 엔티티 매니저 생성이나 팩토리 생성 등을 자동으로 해준다.
05. @PersistenceContext 애노테이션을 통해 스프링 부트를 사용하기 때문에 스프링 컨테이너 위에서 동작하는데 컨테이너에서 entity manger 주입을 해준다.
06. 스타일의 차일순 있지만 커맨드와 쿼리를 분리하라는 원칙으로 인해 저장을 한 뒤 멤버 객체를 반환하는 것이 아닌 id를 넘겨서 다시 조회가 가능하기 때문에 리턴을 long으로 해주게 된다.
07. **모든 엔티티 매니저 통한 모든 데이터 변경은 트랜잭션에서 이루어 져야 한다.**
08. @Transactional 애노테이션이 test에 있으면 테스트가 끝난 뒤 롤백을 해버린다.
09. **같은 영속성이라면 Member와 find 한 Member는 같아야 한다.**
10. **Order와 Member는 다대일 관계. 때문에 Order 엔티티에 @ManyToOne**
11. **@OneToMany(mappedBy = "member") 애노테이션이 있는 경우는 나는 맵핑이 된 것이다 라는 표현. 즉 나는 거울이다. 주인을 넣어준다. 즉 주인은 member**
12. Setter를 열어두지 말자. (엔티티에도 마찬가지)
13. **모든 연관관계는 지연로딩으로 설정! 즉시로딩은 예측이 어렵다.**
14. 즉시로딩이라 한번 로딩할때 관련된 애들 모두를 조회한다는거 (테이블에 연관된 모든 테이블 모두 조회)
15. X to One 의 경우 fetch 전략이 EAGER로 되어 있기 때문에 직접 설정을 해줘야 한다.
16. 콜렉션은 생성 즉시 초기화 해준다. 하이버네이트가 영속하자마자 컬렉션을 한번 감싸기 때문. 때문에 필드 레벨에서 초기화 해주는 것이 안전하다.
17. 엔티티에 있는 콜렉션은 초기화 해주고 바꾸지 말고 그냥 쓰도록하자.
18. 연관관계 메서드는 컨트롤 하는쪽에 있는 것이 편하다.
19. JPQL은 from의 대상이 테이블이 아닌 엔티티를 목표로 짜는 쿼리라고 생각하면 된다.
20. em.persist 호출을 하면 키가 pk 값인 id가 되고 영속성에 있을 때 (db에 값이 들어가기 전에) id 값이 박혀있게 된다.
21. 회원이 있는지 체크하는 로직에서는 동시에 값이 insert 되는 경우를 고려하여 닉네임 같은 경우에는 유니크로 걸어주면 좋다. (한번 더 방어)
22. 인젝션 필드는 바꿀 수 없는 단점이 있고, (private 이니) 목 객체를 넣기도 어렵다. 때문에 setter 인젝션을 쓸수도 있는데, 이 또한 별로인 방식인데, 굳이 세터를 호출 할 일이 별로 없다는 것이다. (굳이 열어 놓을필요가 없다)
때문에 생성자 인젝션을 사용하도록 하자. 이 경우 테스트케이스에서도 사용이 편하고, 생성 시점에 생성해야한다는 시점을 알려줄수있기 때문에 좋은 방식!
23. 생성자 인젝션의 경우 생성자가 딱 하나만 있는 경우에는 @Autowired 애노테이션이 없어도 알아서 인젝션 해준다.
24. 그리고 서비스 안의 repository는 final로 하자! 그리고 롬복의 @RequiredArgsConstructor 사용하면 Final 필드만 생성자를 만들어준다!
25. spring data jpa가 @PersistenceContext 애노테이션을 -> @Autowired로 만들어준다. 때문에 24번과 같이 롬복을 사용 할 수 있다!