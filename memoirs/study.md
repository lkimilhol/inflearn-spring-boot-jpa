01. implementation 'org.springframework.boot:spring-boot-devtools' 의존성을 추가하고 html 페이지 편집 후 build에서 recompile을 해주면 서버를 다시 띄우지 않아도 html 페이지에 반영이 된다.
02. h2 데이터베이스는 처음에는 파일 모드로 파일을 생성을 하지만 그 이후로는 tcp를 붙여서 네트워크 모드로 접속하게 한다.
03. @Repository는 component scan 대상이다.
04. spring-boot-stater-data-jpa를 통해서 엔티티 매니저 생성이나 팩토리 생성 등을 자동으로 해준다.
05. @PersistenceContext 애노테이션을 통해 스프링 부트를 사용하기 때문에 스프링 컨테이너 위에서 동작하는데 컨테이너에서 entity manger 주입을 해준다.
06. 스타일의 차일순 있지만 커맨드와 쿼리를 분리하라는 원칙으로 인해 저장을 한 뒤 멤버 객체를 반환하는 것이 아닌 id를 넘겨서 다시 조회가 가능하기 때문에 리턴을 long으로 해주게 된다.
07. **모든 엔티티 매니저 통한 모든 데이터 변경은 트랜잭션에서 이루어 져야 한다.**
08. @Transactional 애노테이션이 test에 있으면 테스트가 끝난 뒤 롤백을 해버린다.
09. **같은 영속성이라면 Member와 find 한 Member는 같아야 한다.**
10. **Order와 Member는 다대일 관계. 때문에 Order 엔티티에 @ManyToOne**
11. **@OneToMany(mappedBy = "member") 애노테이션이 있는 경우는 나는 맵핑이 된 것이다 라는 표현. 즉 나는 거울이다. 주인을 넣어준다. 즉 주인은 member**
12. Setter를 열어두지 말자. (엔티티에도 마찬가지)
13. **모든 연관관계는 지연로딩으로 설정! 즉시로딩은 예측이 어렵다.**
14. 즉시로딩이라 한번 로딩할때 관련된 애들 모두를 조회한다는거 (테이블에 연관된 모든 테이블 모두 조회)
15. X to One 의 경우 fetch 전략이 EAGER로 되어 있기 때문에 직접 설정을 해줘야 한다.
16. 콜렉션은 생성 즉시 초기화 해준다. 하이버네이트가 영속하자마자 컬렉션을 한번 감싸기 때문. 때문에 필드 레벨에서 초기화 해주는 것이 안전하다.
17. 엔티티에 있는 콜렉션은 초기화 해주고 바꾸지 말고 그냥 쓰도록하자.
18. 연관관계 메서드는 컨트롤 하는쪽에 있는 것이 편하다.
19. JPQL은 from의 대상이 테이블이 아닌 엔티티를 목표로 짜는 쿼리라고 생각하면 된다.
20. em.persist 호출을 하면 키가 pk 값인 id가 되고 영속성에 있을 때 (db에 값이 들어가기 전에) id 값이 박혀있게 된다.
21. 회원이 있는지 체크하는 로직에서는 동시에 값이 insert 되는 경우를 고려하여 닉네임 같은 경우에는 유니크로 걸어주면 좋다. (한번 더 방어)
22. 인젝션 필드는 바꿀 수 없는 단점이 있고, (private 이니) 목 객체를 넣기도 어렵다. 때문에 setter 인젝션을 쓸수도 있는데, 이 또한 별로인 방식인데, 굳이 세터를 호출 할 일이 별로 없다는 것이다. (굳이 열어 놓을필요가 없다)
때문에 생성자 인젝션을 사용하도록 하자. 이 경우 테스트케이스에서도 사용이 편하고, 생성 시점에 생성해야한다는 시점을 알려줄수있기 때문에 좋은 방식!
23. 생성자 인젝션의 경우 생성자가 딱 하나만 있는 경우에는 @Autowired 애노테이션이 없어도 알아서 인젝션 해준다.
24. 그리고 서비스 안의 repository는 final로 하자! 그리고 롬복의 @RequiredArgsConstructor 사용하면 Final 필드만 생성자를 만들어준다!
25. spring data jpa가 @PersistenceContext 애노테이션을 -> @Autowired로 만들어준다. 때문에 24번과 같이 롬복을 사용 할 수 있다!
26. 테스트케이스에서 save -> persist 까지 가면 db에 반영이 안된다. 왜냐면 커밋이 되기 전이니까. 영속성에만 올라간것이다. 근데 테스트케이스에서 트랜잭셔날을 걸어뒀기 때문에 insert가 굳이 되지 않고 끝난다.
27. 만약 db에 직접 넣고 싶으면 롤백을 false로 하거나 em.flush를 강제로 호출하면 db까지 들어갔다가 롤백이 되는것을 확인 할 수 있다.
28. 테스트케이스에 따로 resources 폴더를 만들고 설정 파일을 만들면 별도의 설정 없이 인메모리 디비로 테스트케이스가 작동하게 된다.
29. cascade 옵션에서 cascade ALL 옵션을 주면 persit를 했을 때 자동적으로 insert를 해준다. (Order를 save 할 때 로직을 참고)
30. 29번을 쓸 때는 딱 한가지의 용도로만 쓴다. 참조를 한가지 용도로(Order) 하지 않고 여기저기서 참조를 한다면 cascade를 all 옵션을 주지 않는게 좋다. -> 별도의 레포지토리를 만든다.
31. jpa를 쓰면서 생성자를 protected로 한다면 생성자를 사용하지 말라는 의도이다. (static method가 있을 것이다.) -> 생성하는 방식이 여러개면 유지보수시 힘들기 때문
32. jpa의 강점은 주문 취소에서 볼 수 있는데, 취소를 할 경우 transaction 하나로 로직만 구현한다면 알아서 재고 수량을 줄여주거나 상태를 바꾸는 update를 따로 query로 작성할거 없이 더디체킹을 통해 알아서 update 해주게 된다.
33. 서비스 계층에서 엔티티에 필요한 요청만 하고 엔티티가 비즈니스 로직을 가지고있는 경우를 **도메인 모델 패턴**이라고 한다.
34. 엔티티에 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비주니스 로직을 처리하는 것을 **트랙잭션 스크립트 패턴**이라고 한다.
35. 스프링 부트를 실행시키지 말고 각 서비스의 Mocking 을 하여 단위 테스트를 진행하면 좋다.