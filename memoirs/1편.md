01. implementation 'org.springframework.boot:spring-boot-devtools' 의존성을 추가하고 html 페이지 편집 후 build에서 recompile을 해주면 서버를 다시 띄우지 않아도 html 페이지에 반영이 된다.


02. h2 데이터베이스는 처음에는 파일 모드로 파일을 생성을 하지만 그 이후로는 tcp를 붙여서 네트워크 모드로 접속하게 한다.


03. @Repository는 component scan 대상이다.


04. spring-boot-stater-data-jpa를 통해서 엔티티 매니저 생성이나 팩토리 생성 등을 자동으로 해준다.


05. @PersistenceContext 애노테이션을 통해 스프링 부트를 사용하기 때문에 스프링 컨테이너 위에서 동작하는데 컨테이너에서 entity manger 주입을 해준다.


06. 스타일의 차일순 있지만 커맨드와 쿼리를 분리하라는 원칙으로 인해 저장을 한 뒤 멤버 객체를 반환하는 것이 아닌 id를 넘겨서 다시 조회가 가능하기 때문에 리턴을 long으로 해주게 된다.


07. **모든 엔티티 매니저 통한 모든 데이터 변경은 트랜잭션에서 이루어 져야 한다.**


08. @Transactional 애노테이션이 test에 있으면 테스트가 끝난 뒤 롤백을 해버린다.


09. **같은 영속성이라면 Member와 find 한 Member는 같아야 한다.**


10. **Order와 Member는 다대일 관계. 때문에 Order 엔티티에 @ManyToOne**


11. **@OneToMany(mappedBy = "member") 애노테이션이 있는 경우는 나는 맵핑이 된 것이다 라는 표현. 즉 나는 거울이다. 주인을 넣어준다. 즉 주인은 member**


12. Setter를 열어두지 말자. (엔티티에도 마찬가지)


13. **모든 연관관계는 지연로딩으로 설정! 즉시로딩은 예측이 어렵다.**


14. 즉시로딩이라 한번 로딩할때 관련된 애들 모두를 조회한다는거 (테이블에 연관된 모든 테이블 모두 조회)


15. X to One 의 경우 fetch 전략이 EAGER로 되어 있기 때문에 직접 설정을 해줘야 한다.


16. 콜렉션은 생성 즉시 초기화 해준다. 하이버네이트가 영속하자마자 컬렉션을 한번 감싸기 때문. 때문에 필드 레벨에서 초기화 해주는 것이 안전하다.


17. 엔티티에 있는 콜렉션은 초기화 해주고 바꾸지 말고 그냥 쓰도록하자.


18. 연관관계 메서드는 컨트롤 하는쪽에 있는 것이 편하다.


19. JPQL은 from의 대상이 테이블이 아닌 엔티티를 목표로 짜는 쿼리라고 생각하면 된다.


20. em.persist 호출을 하면 키가 pk 값인 id가 되고 영속성에 있을 때 (db에 값이 들어가기 전에) id 값이 박혀있게 된다.


21. 회원이 있는지 체크하는 로직에서는 동시에 값이 insert 되는 경우를 고려하여 닉네임 같은 경우에는 유니크로 걸어주면 좋다. (한번 더 방어)


22. 인젝션 필드는 바꿀 수 없는 단점이 있고, (private 이니) 목 객체를 넣기도 어렵다. 때문에 setter 인젝션을 쓸수도 있는데, 이 또한 별로인 방식인데, 굳이 세터를 호출 할 일이 별로 없다는 것이다. (굳이 열어 놓을필요가 없다) 때문에 생성자 인젝션을 사용하도록 하자. 이 경우 테스트케이스에서도 사용이 편하고, 생성 시점에 생성해야한다는 시점을 알려줄수있기 때문에 좋은 방식!


23. 생성자 인젝션의 경우 생성자가 딱 하나만 있는 경우에는 @Autowired 애노테이션이 없어도 알아서 인젝션 해준다.


24. 그리고 서비스 안의 repository는 final로 하자! 그리고 롬복의 @RequiredArgsConstructor 사용하면 Final 필드만 생성자를 만들어준다!


25. spring data jpa가 @PersistenceContext 애노테이션을 -> @Autowired로 만들어준다. 때문에 24번과 같이 롬복을 사용 할 수 있다!


26. 테스트케이스에서 save -> persist 까지 가면 db에 반영이 안된다. 왜냐면 커밋이 되기 전이니까. 영속성에만 올라간것이다. 근데 테스트케이스에서 트랜잭셔날을 걸어뒀기 때문에 insert가 굳이 되지 않고 끝난다.


27. 만약 db에 직접 넣고 싶으면 롤백을 false로 하거나 em.flush를 강제로 호출하면 db까지 들어갔다가 롤백이 되는것을 확인 할 수 있다.


28. 테스트케이스에 따로 resources 폴더를 만들고 설정 파일을 만들면 별도의 설정 없이 인메모리 디비로 테스트케이스가 작동하게 된다.


29. cascade 옵션에서 cascade ALL 옵션을 주면 persit를 했을 때 자동적으로 insert를 해준다. (Order를 save 할 때 로직을 참고)


30. 29번을 쓸 때는 딱 한가지의 용도로만 쓴다. 참조를 한가지 용도로(Order) 하지 않고 여기저기서 참조를 한다면 cascade를 all 옵션을 주지 않는게 좋다. -> 별도의 레포지토리를 만든다.


31. jpa를 쓰면서 생성자를 protected로 한다면 생성자를 사용하지 말라는 의도이다. (static method가 있을 것이다.) -> 생성하는 방식이 여러개면 유지보수시 힘들기 때문


32. jpa의 강점은 주문 취소에서 볼 수 있는데, 취소를 할 경우 transaction 하나로 로직만 구현한다면 알아서 재고 수량을 줄여주거나 상태를 바꾸는 update를 따로 query로 작성할거 없이 더디체킹을 통해 알아서 update 해주게 된다.


33. 서비스 계층에서 엔티티에 필요한 요청만 하고 엔티티가 비즈니스 로직을 가지고있는 경우를 **도메인 모델 패턴**이라고 한다.


34. 엔티티에 비즈니스 로직이 거의 없고 서비스 계층에서 대부분의 비주니스 로직을 처리하는 것을 **트랙잭션 스크립트 패턴**이라고 한다.


35. 스프링 부트를 실행시키지 말고 각 서비스의 Mocking 을 하여 단위 테스트를 진행하면 좋다.


36. thymeleaf에서 계층형인 hierarchical-style을 사용한다면 계층형으로 include가 반복되는 걸 막아줄 수 있다.


37. valid 애노테이션을 거쳐서 에러가 있을 경우 BindingResult를 거치게 되고 return 시 폼으로 돌려버릴수있다. 그리고 타임리프에서 fields.hashErrors 코드를 통하여 에러 내용을 보여줄 수 있다.


38. valid 검증은 차라리 뷰에서 깔끔하게 에러를 잡아버리는게 낫다.


39. 요구 사항이 간단하다면 멤버 엔티티를 그대로 써도 되지만 요구 사항은 실무에서 단순하지 않다. 때문에 폼 객체나 Dto를 쓰는 것을 추천


40. JPA는 최대한 간결하게, 핵심 비즈니스 로직과의 의존성만 있도록 사용을 해야한다.


41. API를 만들때는 엔티티를 외부로 유출하면 안된다. 왜냐하면 패스워드가 있다고 하면 패스워드가 외부로 노출 될 뿐만 아니라 새로 추가된 필드 때문에 API 스펙이 변하기 때문이다.


42. 변경 감지와 병합의 차이. 변경 감지는 로우를 찾고 나서 set을 통해 값을 변경해버리는것. 로우를 가져왔을 때 이미 영속상태가 되어 있기 때문에 변경 감지가 이뤄지기 때문. 병합은 직접 merge 함수를 호출하는것. merge는 실무에서 거의 사용되지 않는다.


43. 병합인 merge는 내부적으로 식별자 값으로 로우를 찾고 값을 바꿔치기 해버린다. 그럼 무슨 차이가 있을까? 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회. 없으면 db에서 가져옴. 그리고 내가 넘겨준 값(변경하려는 값)을 필드의 모든 값을 바꿔치기 해버림. 그리고 그것을 반환해줌. 그럼 **실제로 내가 넘겨준 값은 영속성 컨텍스트에 포함되지 않고, 반환 된 그 값. merge(item)의 리턴 값이 영속성 컨텍스트에 포함이 된다.**


44. 변경감지는 내가 set을 한 값, 즉 내가 원하는 필드만 업데이트 되지만 **병합시에 값이 채워지지 않은 부분은 null로 업데이트 된다.**


45. 엔티티에 의미있는 메서드를 만들어서 내부에서 업데이트가 이뤄지게 하자. setter가 많으면 안좋다! 쓰지말자!


46. 컨트롤러 딴에서 멤버의 데이터를 가져오거나 한 뒤 서비스로 넘기면 영속성 컨텍스트에서 벗어나게 된다. 이유는 트랜잭션이 끝났기 때문. 차라리 서비스 안에서 모든걸 처리하는것이 좋다.


